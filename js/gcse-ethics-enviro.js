// --- Flashcard Data for Keywords ---
const flashcardData = {
    "electronic waste (e-waste)": "Discarded electrical or electronic devices. Contains toxic materials like lead, mercury, cadmium, which can leach into soil and water if not disposed of properly.",
    "energy consumption": "The use of energy or power. Computing devices and data centres consume significant amounts of electricity, contributing to greenhouse gas emissions if sourced from fossil fuels.",
    "carbon footprint": "The total amount of greenhouse gases (including carbon dioxide and methane) that are generated by our actions. The tech industry has a significant carbon footprint from manufacturing, transportation,and energy use.",
    "data centres": "Facilities used to house computer systems and associated components, such as telecommunications and storage systems. They consume vast amounts of energy for power and cooling.",
    "rare earth materials": "A set of seventeen chemical elements in the periodic table. Essential for many electronic components. Mining them can be environmentally destructive and resource-intensive.",
    "water consumption": "The manufacturing of semiconductors and other electronic components requires large quantities of water, potentially contributing to water scarcity in some regions.",
    "green computing": "The environmentally responsible and eco-friendly use of computers and their resources. Includes practices like energy efficiency, e-waste reduction, and use of sustainable materials.",
    "circular economy": "An economic model focused on minimizing waste and making the most of resources by keeping products and materials in use for as long as possible, through repairing, reusing, refurbishing, and recycling."
};

// --- Global Variables for Scoring ---
let totalPossibleScore = 0;
let currentScore = 0;
let scoreCalculated = false;

// --- Helper: Add Keyword Tooltips ---
function addTooltips() {
    document.querySelectorAll('.keyword').forEach(span => {
        const keywordText = span.textContent.trim().toLowerCase().replace(/[().,]/g, '');
        if (!span.querySelector('.tooltip')) {
            const tooltipDefinition = flashcardData[keywordText];
            if (tooltipDefinition) {
                const tooltip = document.createElement('span');
                tooltip.className = 'tooltip';
                tooltip.textContent = tooltipDefinition;
                span.appendChild(tooltip);
            }
        }
    });
}

// --- Helper: Toggle Reveal ---
function toggleReveal(contentId, buttonElement, revealText, hideText) {
    const content = document.getElementById(contentId);
    if (!content) return;
    content.classList.toggle('show');
    if (buttonElement) {
        buttonElement.textContent = content.classList.contains('show') ? hideText : revealText;
    }
}

// --- Task 1: Impact Matching ---
let selectedImpactTerm = null;
let selectedImpactDef = null;
let impactMatchesMade = {};

function setupImpactMatching() {
    const termList = document.getElementById('impact-term-list');
    const defList = document.getElementById('impact-definition-list');
    const feedbackEl = document.getElementById('impact-matching-feedback');
    if (!termList || !defList) return;

    selectedImpactTerm = null; selectedImpactDef = null; impactMatchesMade = {};
    termList.querySelectorAll('.matching-item').forEach(item => {
        item.classList.remove('selected', 'correct', 'incorrect', 'disabled');
        item.disabled = false;
        item.onclick = () => handleImpactMatchClick(item, 'term');
    });
    defList.querySelectorAll('.matching-item').forEach(item => {
        item.classList.remove('selected', 'correct', 'incorrect', 'disabled');
        item.disabled = false;
        item.onclick = () => handleImpactMatchClick(item, 'definition');
    });

    for (let i = defList.children.length; i >= 0; i--) { // Shuffle definitions
        defList.appendChild(defList.children[Math.random() * i | 0]);
    }

    if (feedbackEl) feedbackEl.classList.remove('show');
    const quizItem = termList.closest('.quiz-item');
    if (quizItem) { quizItem.dataset.answeredCorrectly = "false"; delete quizItem.dataset.answered; }
}

function handleImpactMatchClick(item, type) {
    if (item.disabled) return;
    if (type === 'term') {
        if (selectedImpactTerm) selectedImpactTerm.classList.remove('selected');
        selectedImpactTerm = item; item.classList.add('selected');
    } else {
        if (selectedImpactDef) selectedImpactDef.classList.remove('selected');
        selectedImpactDef = item; item.classList.add('selected');
    }
    if (selectedImpactTerm && selectedImpactDef) attemptImpactMatch();
}

function attemptImpactMatch() {
    const termMatchId = selectedImpactTerm.dataset.match;
    const defMatchId = selectedImpactDef.dataset.match;

    selectedImpactTerm.classList.remove('selected'); selectedImpactDef.classList.remove('selected');

    if (termMatchId === defMatchId) {
        selectedImpactTerm.classList.add('correct'); selectedImpactDef.classList.add('correct');
        selectedImpactTerm.disabled = true; selectedImpactDef.disabled = true;
        impactMatchesMade[termMatchId] = true;
    } else {
        selectedImpactTerm.classList.add('incorrect'); selectedImpactDef.classList.add('incorrect');
        setTimeout(() => {
            if (selectedImpactTerm && !selectedImpactTerm.classList.contains('correct')) selectedImpactTerm.classList.remove('incorrect');
            if (selectedImpactDef && !selectedImpactDef.classList.contains('correct')) selectedImpactDef.classList.remove('incorrect');
        }, 800);
    }
    selectedImpactTerm = null; selectedImpactDef = null;
}

function checkImpactMatches() {
    const feedbackEl = document.getElementById('impact-matching-feedback');
    const termListEl = document.getElementById('impact-term-list');
    if (!termListEl || !feedbackEl) return;

    const totalPairs = termListEl.children.length;
    const correctMatches = Object.keys(impactMatchesMade).length;
    let allAttempted = true;
    termListEl.querySelectorAll('.matching-item').forEach(term => {
        if (!term.disabled) allAttempted = false;
        if (!term.classList.contains('correct') && term.disabled === false) term.classList.add('incorrect');
    });
    document.getElementById('impact-definition-list').querySelectorAll('.matching-item').forEach(def => {
        if (!def.classList.contains('correct') && def.disabled === false) def.classList.add('incorrect');
    });

    if (!allAttempted && totalPairs > 0) {
        alert("Please attempt to match all impacts before checking.");
        return;
    }

    const quizItem = termListEl.closest('.quiz-item');
    if (correctMatches === totalPairs) {
        feedbackEl.innerHTML = `<p class="correct-feedback font-semibold">All impacts matched correctly! (+${quizItem.dataset.points} points)</p>`;
        quizItem.dataset.answeredCorrectly = "true";
    } else {
        feedbackEl.innerHTML = `<p class="incorrect-feedback font-semibold">Some impacts are mismatched. You got ${correctMatches}/${totalPairs} correct. Check red items.</p>`;
        quizItem.dataset.answeredCorrectly = "false";
    }
    feedbackEl.classList.add('show');
    quizItem.dataset.answered = "true";
    if (scoreCalculated) calculateScore();
}
function resetImpactMatches() {
    setupImpactMatching();
    if (scoreCalculated) calculateScore();
}

// --- Task 2: E-Waste Lifecycle Sorter (REVISED) ---
const correctEwasteOrder = ["ewaste-step-extraction", "ewaste-step-manufacturing", "ewaste-step-obsolescence", "ewaste-step-disposal", "ewaste-step-recycling"];
const ewasteSlotPlaceholders = {}; // To store initial HTML of slots
let ewasteDraggedItem = null;      // The item currently being dragged
let ewasteSourceSlotId = null;

// Global variables for Task 4 (new)
let task4Textareas;
let task4CheckButton;



function initializeEwasteSorter() {
    // Setup draggable items in the pool
    document.querySelectorAll('#ewaste-steps-pool .ewaste-step').forEach(item => {
        item.draggable = true; // Ensure draggable is set
        item.addEventListener('dragstart', ewasteDragStart);
         item.addEventListener('dragend', ewasteDragEnd); // Important for cleanup
    });

    // Initialize Task 4 elements (new)
    task4Textareas = document.querySelectorAll('#task4-solutions-brainstorm textarea');
    task4CheckButton = document.getElementById('check-task4-solutions-btn');
    task4Guidance = document.getElementById('solutions-guidance'); // Assuming this ID exists
    task4Feedback = document.getElementById('task4-feedback'); // Assuming this ID exists

    if (task4Textareas && task4CheckButton) {
        task4Textareas.forEach(textarea => textarea.addEventListener('input', updateTask4CheckButtonState));
        updateTask4CheckButtonState(); // Set initial state
    }
    // Call reset to set initial state correctly
    if (typeof resetEwasteLifecycle === 'function') {
        resetEwasteLifecycle();
    }

function ewasteDragStart(event) {
    ewasteDraggedItem = event.target;
    event.dataTransfer.setData('text/plain', event.target.id);
    event.dataTransfer.effectAllowed = 'move';
    event.target.classList.add('opacity-50'); // Visual cue for dragging

    // Check if the item is being dragged from one of the ordered slots
    if (event.target.parentElement && event.target.parentElement.id.startsWith('ewaste-slot-')) {
        ewasteSourceSlotId = event.target.parentElement.id;
    } else {
        ewasteSourceSlotId = null; // Item is from the pool
    }
}

function ewasteDragEnd(event) {
    if (ewasteDraggedItem) { // ewasteDraggedItem might be null if drag was cancelled
        ewasteDraggedItem.classList.remove('opacity-50');
    }

    // If an item was dragged FROM a slot, and that slot is now empty
    // (because the item was dropped elsewhere OR the drag was cancelled by dropping outside a valid target),
    // then restore its placeholder.
    if (ewasteSourceSlotId) {
        const sourceSlot = document.getElementById(ewasteSourceSlotId);
        if (sourceSlot && sourceSlot.children.length === 0 && ewasteSlotPlaceholders[sourceSlot.id] !== undefined) {
            sourceSlot.innerHTML = ewasteSlotPlaceholders[sourceSlot.id];
        }
    }
    ewasteDraggedItem = null;
    ewasteSourceSlotId = null;
}

// Function to update the state of the Task 4 check button (new)
function updateTask4CheckButtonState() {
    if (!task4Textareas || !task4CheckButton) return;
    let allFilled = true;
    task4Textareas.forEach(textarea => {
        if (textarea.value.trim().length === 0) allFilled = false;
    });
    task4CheckButton.disabled = !allFilled;
}

function ewasteDragOver(event) {
    event.preventDefault(); // Necessary to allow dropping
}

function ewasteDragEnter(event) {
    event.preventDefault();
    const dropTarget = event.currentTarget;
    // Make sure currentTarget is a valid drop zone (a slot or the pool)
    if (dropTarget.id.startsWith('ewaste-slot-') || dropTarget.id === 'ewaste-steps-pool') {
        dropTarget.classList.add('bg-indigo-100', 'border-indigo-400'); // Visual cue for valid drop target
    }
}

function ewasteDragLeave(event) {
    const dropTarget = event.currentTarget;
    if (dropTarget.id.startsWith('ewaste-slot-') || dropTarget.id === 'ewaste-steps-pool') {
        dropTarget.classList.remove('bg-indigo-100', 'border-indigo-400');
    }
}

function ewasteDrop(event) {
    event.preventDefault();
    const dropTarget = event.currentTarget;
    dropTarget.classList.remove('bg-indigo-100', 'border-indigo-400');

    if (!ewasteDraggedItem) return; // Should not happen if dragstart was successful

    const targetIsSlot = dropTarget.id.startsWith('ewaste-slot-');
    const targetIsPool = dropTarget.id === 'ewaste-steps-pool';

    if (targetIsSlot) {
        // If the target slot already contains an item, move that item back to the pool
        if (dropTarget.children.length > 0 && dropTarget.firstChild !== ewasteDraggedItem) {
            const existingItem = dropTarget.firstChild;
            document.getElementById('ewaste-steps-pool').appendChild(existingItem);
            // Ensure items moved back to the pool are draggable again (already handled by initial setup)
        }

        // If the dragged item came FROM a different slot, restore that original slot's placeholder
        if (ewasteSourceSlotId && ewasteSourceSlotId !== dropTarget.id) {
            const originalSlot = document.getElementById(ewasteSourceSlotId);
            if (originalSlot && originalSlot.children.length === 0 && ewasteSlotPlaceholders[originalSlot.id] !== undefined) {
                originalSlot.innerHTML = ewasteSlotPlaceholders[originalSlot.id];
            }
        }
        
        dropTarget.innerHTML = ''; // Clear current content (placeholder or old item)
        dropTarget.appendChild(ewasteDraggedItem);

    } else if (targetIsPool) {
        // If the item was dragged from a slot and is now being dropped back into the pool
        if (ewasteSourceSlotId) {
            const originalSlot = document.getElementById(ewasteSourceSlotId);
            if (originalSlot && ewasteSlotPlaceholders[originalSlot.id] !== undefined) {
                originalSlot.innerHTML = ewasteSlotPlaceholders[originalSlot.id]; // Restore placeholder
            }
        }
        dropTarget.appendChild(ewasteDraggedItem); // Add item to pool
        // Remove any correctness styling if it was in a slot
        ewasteDraggedItem.classList.remove('correct', 'incorrect');
    }
    // ewasteDraggedItem and ewasteSourceSlotId are reset in ewasteDragEnd
}

function checkEwasteLifecycle() {
    const feedbackDiv = document.getElementById('ewaste-lifecycle-feedback');
    const task2Container = document.getElementById('task2-ewaste-lifecycle');
    if (!task2Container || !feedbackDiv) return;

    const quizItem = task2Container.querySelector('.quiz-item');
    if (!quizItem) return;

    let allSlotsFilled = true;
    const placedItems = [];
    for (let i = 0; i < correctEwasteOrder.length; i++) {
        const slot = document.getElementById(`ewaste-slot-${i}`);
        const itemInSlot = slot ? slot.querySelector('.ewaste-step') : null;
        if (!itemInSlot) {
            allSlotsFilled = false;
        }
        placedItems.push(itemInSlot); // Will contain the item or null
    }

    if (!allSlotsFilled) {
        alert("Please drag a lifecycle stage into each of the order slots.");
        return;
    }

    let correctOrderCount = 0;
    placedItems.forEach((step, index) => {
        if (step) { // Should always be true due to allSlotsFilled check
            step.classList.remove('correct', 'incorrect');
            if (step.id === correctEwasteOrder[index]) {
                step.classList.add('correct', 'text-white', '!bg-green-500', 'border-green-700');
                correctOrderCount++;
            } else {
                step.classList.add('incorrect', 'text-white', '!bg-red-500', 'border-red-700');
            }
        }
    });

    quizItem.dataset.answered = "true";
    if (correctOrderCount === correctEwasteOrder.length) {
        feedbackDiv.innerHTML = `<p class="correct-feedback font-semibold">Correct order! Well done! (+${quizItem.dataset.points} points)</p>`;
        quizItem.dataset.answeredCorrectly = "true";
    } else {
        feedbackDiv.innerHTML = `<p class="incorrect-feedback font-semibold">Not quite the right order. You got ${correctOrderCount}/${correctEwasteOrder.length} steps correct. Review the highlighted items.</p>`;
        quizItem.dataset.answeredCorrectly = "false";
    }
    feedbackDiv.classList.add('show');
    if (scoreCalculated) calculateScore();
}

function resetEwasteLifecycle() {
    const pool = document.getElementById('ewaste-steps-pool');
    if (!pool) return;

    // Move items from slots back to pool and restore slot placeholders
    for (let i = 0; i < correctEwasteOrder.length; i++) {
        const slot = document.getElementById(`ewaste-slot-${i}`);
        if (slot) {
            const itemInSlot = slot.querySelector('.ewaste-step');
            if (itemInSlot) {
                itemInSlot.classList.remove('correct', 'incorrect', 'text-white', '!bg-green-500', 'border-green-700', '!bg-red-500', 'border-red-700', 'opacity-50');
                pool.appendChild(itemInSlot);
            }
            // Restore the original placeholder HTML (empty styled div)
            if (ewasteSlotPlaceholders[slot.id] !== undefined) {
                slot.innerHTML = ewasteSlotPlaceholders[slot.id];
            } else {
                slot.innerHTML = ''; // Fallback: just clear it
            }
            slot.classList.remove('drag-over-active', 'bg-indigo-100', 'border-indigo-400');
        }
    }

    // Ensure all original draggable items are in the pool and reset their styles
    const originalItemIds = [
        "ewaste-step-disposal", "ewaste-step-manufacturing",
        "ewaste-step-obsolescence", "ewaste-step-extraction", "ewaste-step-recycling"
    ];
    originalItemIds.forEach(id => {
        const item = document.getElementById(id);
        if (item) {
            if (item.parentElement !== pool) {
                pool.appendChild(item); // Ensure it's in the pool
            }
            item.classList.remove('correct', 'incorrect', 'text-white', '!bg-green-500', 'border-green-700', '!bg-red-500', 'border-red-700', 'opacity-50');
            item.draggable = true; // Ensure it's draggable
        }
    });
    
    // Clear feedback and reset state
    const feedbackArea = document.getElementById('ewaste-lifecycle-feedback');
    if (feedbackArea) {
        feedbackArea.innerHTML = '';
        feedbackArea.classList.remove('show');
    }
    
    const quizItem = document.querySelector('#task2-ewaste-lifecycle .quiz-item');
    if (quizItem) {
        quizItem.dataset.answeredCorrectly = "false";
        delete quizItem.dataset.answered;
    }

    ewasteDraggedItem = null;
    ewasteSourceSlotId = null;
    if (scoreCalculated) calculateScore();
}


// --- Task 3: Data Centre Sim ---
const serverLoadSlider = document.getElementById('server-load-slider');
const coolingSlider = document.getElementById('cooling-slider');
const datacenterVisual = document.getElementById('datacenter-visual');
const coolingVisual = document.getElementById('cooling-visual');
const energyStatus = document.getElementById('datacenter-energy-status');

function updateDatacenterSim() {
    if (!serverLoadSlider || !coolingSlider || !datacenterVisual || !coolingVisual || !energyStatus) return;
    const load = parseInt(serverLoadSlider.value);
    const coolingEfficiency = parseInt(coolingSlider.value); // 1 (low) to 5 (high)

    document.getElementById('server-load-value').textContent = load;
    document.getElementById('cooling-value').textContent = coolingEfficiency;

    datacenterVisual.innerHTML = ''; // Clear previous racks
    const totalRacks = 20; // Max visual racks
    const activeRacks = Math.ceil((load / 100) * totalRacks);

    for (let i = 0; i < totalRacks; i++) {
        const rack = document.createElement('div');
        rack.className = 'server-rack-visual';
        if (i < activeRacks) rack.classList.add('active');
        datacenterVisual.appendChild(rack);
    }

    let energyDemand = load * 2; // Base energy for load
    let coolingDemand = load * 1.5; // Cooling needed is proportional to load
    let coolingProvided = coolingEfficiency * 30; // Max cooling provided by efficient system

    let statusText = "";
    coolingVisual.classList.remove('overloaded');

    if (coolingProvided < coolingDemand && load > 30) { // Only show overloaded if load is somewhat significant
        statusText = "Cooling system struggling! High energy use.";
        coolingVisual.classList.add('overloaded');
        energyDemand += (coolingDemand - coolingProvided) * 0.5; // Extra energy for struggling cooling
    } else if (load > 70) {
        statusText = "High server load, significant energy use.";
    } else if (load > 30) {
        statusText = "Moderate server load and energy use.";
    } else {
        statusText = "Low server load, optimized energy use.";
    }
    energyStatus.textContent = `${statusText} (Conceptual Energy Units: ${Math.round(energyDemand + (coolingDemand / coolingEfficiency * 5))})`;
}
function checkDatacenterAnswers() {
    const q1AnswerEl = document.getElementById('datacenter-q1');
    const feedbackDiv = document.getElementById('task3-feedback');
    const quizItem = q1AnswerEl.closest('.quiz-item');
    const answer = q1AnswerEl.value.toLowerCase();
    let correctPoints = 0;
    let feedbackHtml = "<ul>";

    if (answer.trim().length < 10) {
        feedbackHtml += `<li class="incorrect-feedback"><i class="fas fa-times mr-1"></i>Please provide a more detailed answer.</li>`;
    } else {
        if (answer.includes("powering server") || answer.includes("running server") || answer.includes("electricity for servers")) {
            feedbackHtml += `<li class="correct-feedback"><i class="fas fa-check mr-1"></i>Mentioned powering servers.</li>`; correctPoints++;
        } else {
            feedbackHtml += `<li class="incorrect-feedback"><i class="fas fa-times mr-1"></i>Missing: Powering the servers themselves.</li>`;
        }
        if (answer.includes("cooling") || answer.includes("air conditioning") || answer.includes("temperature control")) {
            feedbackHtml += `<li class="correct-feedback"><i class="fas fa-check mr-1"></i>Mentioned cooling systems.</li>`; correctPoints++;
        } else {
            feedbackHtml += `<li class="incorrect-feedback"><i class="fas fa-times mr-1"></i>Missing: Energy for cooling systems.</li>`;
        }
    }
    feedbackHtml += "</ul>";
    quizItem.dataset.answeredCorrectly = (correctPoints === 2).toString();
    quizItem.dataset.answered = "true";
    feedbackDiv.innerHTML = `<p class="${correctPoints === 2 ? 'correct-feedback' : 'incorrect-feedback'} font-semibold">You identified ${correctPoints}/2 main reasons.</p>${feedbackHtml}`;
    feedbackDiv.classList.add('show');
    if (scoreCalculated) calculateScore();
}
function resetDatacenterTask() {
    if (serverLoadSlider) serverLoadSlider.value = 50;
    if (coolingSlider) coolingSlider.value = 3;
    updateDatacenterSim();
    document.getElementById('datacenter-q1').value = '';
    document.getElementById('task3-feedback').classList.remove('show');
    const quizItem = document.querySelector('#task3-datacenter-sim .quiz-item');
    quizItem.dataset.answeredCorrectly = "false";
    delete quizItem.dataset.answered;
    if (scoreCalculated) calculateScore();
}

// --- Exam Practice Question Logic ---
function toggleMarkScheme(markSchemeId, textareaId, minLength = 10) {
    const markSchemeDiv = document.getElementById(markSchemeId);
    const textarea = document.getElementById(textareaId);
    const buttonElement = event.target;

    if (!markSchemeDiv) return;

    if (!markSchemeDiv.classList.contains('show')) {
        if (textarea && textarea.value.trim().length < minLength) {
            alert(`Please attempt a more detailed answer (at least ${minLength} characters) before viewing the mark scheme.`);
            return;
        }
    }
    toggleReveal(markSchemeId, buttonElement, 'Show Mark Scheme', 'Hide Mark Scheme');
}

// --- Final Score Calculation ---
function calculateScore() {
    currentScore = 0;
    totalPossibleScore = 0;
    scoreCalculated = true;

    document.querySelectorAll('.quiz-item').forEach(item => {
        if (item.closest('#starter-activity') || item.closest('#exam-practice-environmental') || item.closest('#task4-solutions-brainstorm')) return;

        const points = parseInt(item.dataset.points || 0);
        totalPossibleScore += points;
        if (item.dataset.answeredCorrectly === 'true') {
            currentScore += points;
        }
    });

    const scoreDisplayEl = document.getElementById('final-score-display');
    const feedbackDisplay = document.getElementById('final-score-feedback');
    const scoreArea = document.getElementById('final-score-area');

    scoreDisplayEl.textContent = `Your interactive task score: ${currentScore} / ${totalPossibleScore}`;
    let percentage = totalPossibleScore > 0 ? (currentScore / totalPossibleScore) * 100 : 0;
    let feedbackMessage = "";

    if (percentage === 100) feedbackMessage = "Excellent! Full marks on interactive tasks!";
    else if (percentage >= 75) feedbackMessage = "Great job! You have a strong understanding.";
    else if (percentage >= 50) feedbackMessage = "Good effort! Review any tasks you found tricky.";
    else feedbackMessage = "Keep practicing! Revisit the tasks and explanations to improve.";

    feedbackDisplay.textContent = feedbackMessage;
    feedbackDisplay.className = `text-purple-600 ${percentage >= 75 ? 'font-semibold' : ''}`;
    scoreArea.style.display = 'block';
    scoreArea.scrollIntoView({ behavior: 'smooth' });
}
// Function to handle the click of the Task 4 check button (new)
function checkTask4Solutions() {
    if (!task4Guidance || !task4Feedback) return;
    task4Guidance.classList.remove('hidden'); // Reveal the example solutions
    task4Feedback.innerHTML = '<p class="text-green-700 font-semibold">Review the example solutions above and compare them to your ideas!</p>'; // Provide feedback
}
}
// Function to reset Task 4 (new)
function resetTask4Solutions() {
    if (!task4Textareas || !task4CheckButton || !task4Guidance || !task4Feedback) return;
    task4Textareas.forEach(textarea => textarea.value = ''); // Clear textareas
    task4Guidance.classList.add('hidden'); // Hide guidance again
    task4Feedback.innerHTML = ''; // Clear feedback
    updateTask4CheckButtonState(); // Disable the button
}

// Modify the overall reset function if it exists (assuming it's called resetAllTasks)
// If you don't have a resetAllTasks, you might need to add event listeners to individual reset buttons
// and ensure they call resetTask4Solutions if needed
// --- Reset All Tasks ---
function resetAllTasks() {
    if (!confirm("Are you sure you want to reset all tasks? Your progress will be lost.")) return;
    // Reset Starter
    ['starter-q1-devices', 'starter-q2-energy', 'starter-q3-cloud'].forEach(id => {
        const el = document.getElementById(id); if (el) el.value = '';
    });
    const starterFeedbackDiv = document.getElementById('starter-answers-feedback');
    if(starterFeedbackDiv && starterFeedbackDiv.classList.contains('show')) starterFeedbackDiv.classList.remove('show');


    // Reset Tasks
    resetImpactMatches();
    resetEwasteLifecycle(); // This will now call the corrected version
    resetDatacenterTask();

    // Reset Task 4 (Solutions Brainstorm)
    ['solution-ewaste', 'solution-energy', 'solution-materials'].forEach(id => {
        const el = document.getElementById(id); if (el) el.value = '';
    });
    const solutionsGuidanceDiv = document.getElementById('solutions-guidance');
     if(solutionsGuidanceDiv && solutionsGuidanceDiv.classList.contains('show')) solutionsGuidanceDiv.classList.remove('show');


    // Reset Exam Practice
    ['exam-q1-env', 'exam-q2-env', 'exam-q3-env'].forEach(id => {
        const el = document.getElementById(id); if (el) el.value = '';
    });
    ['ms-exam-q1-env', 'ms-exam-q2-env', 'ms-exam-q3-env'].forEach(id => {
        const msDiv = document.getElementById(id);
        const msButton = document.querySelector(`button[onclick*="'${id}'"]`);
        if (msDiv && msDiv.classList.contains('show')) {
             msDiv.classList.remove('show');
             if(msButton) msButton.textContent = 'Show Mark Scheme';
        }
    });

    // Reset Read Checkboxes
    document.querySelectorAll('.read-checkbox').forEach(checkbox => checkbox.checked = false);
    // Reset Final Score
    currentScore = 0; scoreCalculated = false;
    const finalScoreArea = document.getElementById('final-score-area');
    if (finalScoreArea) finalScoreArea.style.display = 'none';
    
    const finalScoreDisplay = document.getElementById('final-score-display');
    if (finalScoreDisplay) finalScoreDisplay.textContent = 'Your score: 0 / 0'; // Recalculate total possible if needed or set default
    
    const finalScoreFeedback = document.getElementById('final-score-feedback');
    if(finalScoreFeedback) finalScoreFeedback.textContent = '';


    alert("All tasks have been reset.");
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// --- PDF Export ---
function exportToPDF() {
    alert("Preparing PDF. This might take a moment. Please ensure pop-ups are allowed. Interactive elements might not be fully captured in their current state.");
    const element = document.querySelector('.max-w-4xl.mx-auto.bg-white');
    const opt = {
        margin: [0.5, 0.5, 0.7, 0.5], // top, left, bottom, right (inches)
        filename: 'gcse-environmental-impact-lesson.pdf',
        image: { type: 'jpeg', quality: 0.95 },
        html2canvas: { scale: 2, logging: false, useCORS: true, scrollY: -window.scrollY },
        jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' },
        pagebreak: { mode: ['avoid-all', 'css', 'legacy'] }
    };

    const revealableElements = document.querySelectorAll('.feedback-area, .quiz-feedback, .mark-scheme, .reveal-content');
    const initiallyHidden = [];
    revealableElements.forEach(el => {
        if (!el.classList.contains('show')) { initiallyHidden.push(el); el.classList.add('show'); }
    });
    const finalScoreArea = document.getElementById('final-score-area');
    let finalScoreWasHidden = true;
    if (finalScoreArea) {
        finalScoreWasHidden = finalScoreArea.style.display === 'none';
        if (finalScoreWasHidden) finalScoreArea.style.display = 'block';
    }
    

    const exportButton = document.getElementById('export-pdf-button');
    const resetButton = document.getElementById('reset-all-tasks');
    const calcScoreButton = document.getElementById('calculate-final-score');
    if (exportButton) exportButton.disabled = true;
    if (resetButton) resetButton.disabled = true;
    if (calcScoreButton) calcScoreButton.disabled = true;

    html2pdf().from(element).set(opt).save().then(function () {
        initiallyHidden.forEach(el => el.classList.remove('show'));
        if (finalScoreArea && finalScoreWasHidden) finalScoreArea.style.display = 'none';
        if (exportButton) exportButton.disabled = false;
        if (resetButton) resetButton.disabled = false;
        if (calcScoreButton) calcScoreButton.disabled = false;
    }).catch(function (error) {
        console.error("Error generating PDF:", error);
        initiallyHidden.forEach(el => el.classList.remove('show'));
        if (finalScoreArea && finalScoreWasHidden) finalScoreArea.style.display = 'none';
        if (exportButton) exportButton.disabled = false;
        if (resetButton) resetButton.disabled = false;
        if (calcScoreButton) calcScoreButton.disabled = false;
    });
}

// --- DOMContentLoaded ---
document.addEventListener('DOMContentLoaded', () => {
    addTooltips();
    setupImpactMatching();
    initializeEwasteSorter(); // Calls the new setup for Task 2
    updateDatacenterSim(); // Initial call for sim
    if (serverLoadSlider) serverLoadSlider.addEventListener('input', updateDatacenterSim);
    if (coolingSlider) coolingSlider.addEventListener('input', updateDatacenterSim);

    // Calculate initial total possible score
    totalPossibleScore = 0;
    document.querySelectorAll('.quiz-item').forEach(item => {
        // Ensure only scorable items are counted
        if (item.closest('#starter-activity') || item.closest('#exam-practice-environmental') || item.closest('#task4-solutions-brainstorm')) return;
        totalPossibleScore += parseInt(item.dataset.points || 0);
    });
    const finalScoreDisplay = document.getElementById('final-score-display');
    if (finalScoreDisplay) {
        finalScoreDisplay.textContent = `Your score: 0 / ${totalPossibleScore}`;
    }


    const calcFinalScoreButton = document.getElementById('calculate-final-score');
    if(calcFinalScoreButton) calcFinalScoreButton.addEventListener('click', calculateScore);
    
    const resetAllTasksButton = document.getElementById('reset-all-tasks');
    if(resetAllTasksButton) resetAllTasksButton.addEventListener('click', resetAllTasks);

    const exportPdfButton = document.getElementById('export-pdf-button');
    if(exportPdfButton) exportPdfButton.addEventListener('click', exportToPDF);
});